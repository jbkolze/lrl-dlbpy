from tkinter import *
from tkinter import filedialog
from tkinter import font as tkFont
import time
from datetime import datetime
import ratings
import os
from os.path import exists
import re
from tkinter import messagebox as mb
import urllib.request
from PIL import ImageGrab
import matplotlib.pyplot as plt
from matplotlib.backends.backend_tkagg import FigureCanvasTkAgg
from matplotlib.dates import DateFormatter, DayLocator
from matplotlib.ticker import FormatStrFormatter
import seaborn as sns
import pandas as pd
from typing import Dict, List, Tuple

pd.plotting.register_matplotlib_converters()


class EntryLabel(Message):
    """A standard Message object with default parameters for dlbpy.
    
    Default settings for EntryLabel include:
    - justify = CENTER
    - aspect = 200
    """

    def __init__(self, parent: Widget, text: str, **kwargs):
        """Inits an EntryLabel with the specified text in the specified frame.
        Args:
            parent: The parent frame of the EntryLabel.
            text: The text to be displayed in the EntryLabel.
        """
        super().__init__(
            parent,
            text=text,
            justify=CENTER,
            aspect=200,
            **kwargs,
        )


class DlbLabelFrame(LabelFrame):
    """A standard LabelFrame object with default parameters for dlbpy.
    Default settings for DlbLabelFrame include:
    - borderwidth = 2
    - padx = 2
    - pady = 2
    """

    def __init__(self, parent: Widget, text: str, **kwargs):
        """Inits a DlbLabelFrame with the specified title in the specified frame.
        Args:
            parent: The parent frame of the DlbLabelFrame.
            text: The title to be displayed on the LabelFrame.
        """
        super().__init__(
            parent,
            text=text,
            borderwidth=2,
            padx=5,
            pady=10,
            **kwargs,
        )


def build_plot(parent: Widget, data: Dict[str, float], title: str, limits: List[float] = None):
    """Constructs a standard line-plot of the provided data as a Tkinter canvas.
    Args:
        parent: The parent frame of the plot.
        data: A dict of the data to be plotted (x: y).
        title: The title to be displayed on the plot.
        limit: An optional list of [NWS flood stage, WCM (rising) limit]
    Returns:
        FigureCanvasTkAgg: A mock-canvas generated by the matplotlib library.  Standard
            tk functions can be accessed through the method get_tk_widget().
    """
    sns.set()
    sns.set_context("paper")
    sns.set_style("whitegrid")
    f, ax = plt.subplots(1, 1, figsize=(2, 2), dpi=100, constrained_layout=True)
    times = [datetime.strptime(x, '%Y-%m-%d %H:%M') for x in list(data.keys())]
    values = list(data.values())
    sns.lineplot(times, values, ax=ax)
    sns.despine(f, ax)
    plt.xticks(rotation=90)
    plt.title(title)
    Y,M,D,h,m,s,wd,yd,dst = time.localtime(time.time()-7*24*60*60)
    X1 = datetime(Y,M,D,0,0)
    Y,M,D,h,m,s,wd,yd,dst = time.localtime()
    X2 = datetime(Y,M,D,6,0)
    plt.xlim([X1,X2])
    ax.xaxis.set_major_locator(DayLocator())
    ax.xaxis.set_major_formatter(DateFormatter('%b %d'))
    ax.yaxis.set_major_formatter(FormatStrFormatter('%.2f'))
    if limits:
        set_plot_limits(limits)
    canvas = FigureCanvasTkAgg(f, master=parent)
    return canvas

def set_plot_limits(limits: List[float]):
    """Appends stage limit markers to the active plot using a standard form.

    Args:
        limits: A list of floats containing [NWS flood stage, WCM (rising) limit]
    """
    line_options = [
        ['red', 'dashed'],
        ['black', 'dotted'],
    ]
    for i, limit in enumerate(limits):
        if limit:
            opts = line_options[i]
            plt.axhline(limit, color=opts[0], ls=opts[1])


def Interpolate(Data,datestamp):
    """Checks the data to see if the datestamp is within the dataset and interpolate if not
        Return:
            float|str: Value, Interpolated value or empty string if there isn't data within 59 minutes above and below the value to interpolate from
    """
    try:
        return Data[datestamp]
    except:
        x = time.mktime(time.strptime(datestamp,'%Y-%m-%d %H:%M'))
        dates = list(Data.keys())
        dates.sort()
        i = 0
        while dates[i]< datestamp:
            i+=1
        x1,x2 =time.mktime(time.strptime(dates[i-1],'%Y-%m-%d %H:%M')),time.mktime(time.strptime(dates[i],'%Y-%m-%d %H:%M'))
        y1,y2 = Data[dates[i-1]],Data[dates[i]]
        if abs (x-x1) < 59*60 and abs (x-x2) < 59*60:
            return round(y1 + (x-x1)*((y2-y1)/(x2-x1)),2)
        else:
            return ''
def LastGood(Data,datestamp,minutes_back=60):
    try:
        return Data[datestamp]
    except:
        x = time.mktime(time.strptime(datestamp,'%Y-%m-%d %H:%M'))
        dates = list(Data.keys())
        dates.sort()
        i = -1
        diff = minutes_back*2*60
        while (abs(time.mktime(time.strptime(dates[i],'%Y-%m-%d %H:%M')) - x) <= minutes_back*60) or time.mktime(time.strptime(dates[i],'%Y-%m-%d %H:%M')) > x:
            if abs(time.mktime(time.strptime(dates[i],'%Y-%m-%d %H:%M')) - x) <= diff:
                diff = abs(time.mktime(time.strptime(dates[i],'%Y-%m-%d %H:%M')) - x)
                return_value = Data[dates[i]]
            i -= 1
        return return_value
    
def GetBasin(lake):
    """Checks the basin_lakes dictionary for the lake code
        Returns:
            str: A string containing the basin code or an empty string if the lake code
            is not valid
    """
    basin_lakes = {'GRB':['GRR','NRR','BRR','RRR'],'MAB':['WFR','CBR','CCK','WHL'],
               'MWB':['CHL','CMR','MNR','PRR'],'SRB':['TVL'],'UKL':['CFK','BHR','CRR'],
               'UWB':['HTR','SRR','MSR'],'WWB':['BVR']}
    for key in basin_lakes.keys():
        if lake in basin_lakes[key]:
            return key
    return ''
def pad(t,l,s):
    """Pads string t with character s until length is not less than l
        Returns:
            str: A string containing the contents of t with s appended to the front a number of times
            to make the total length equal to l
    """
    while len(t) < l:
        t = s+t
    return t
def datatypes(rdbfile):
    datatypes = []
    for line in rdbfile.split('\n'):
        if line[13:15] == 'TS':
            StartOfDD = 1
        try:
            if line[0] == '#'  and StartOfDD:
                matchobj = re.match('#\D*(\d+)\D*(\d\d\d\d\d)\w*([^\[\]]*)(\[\\S+.*?\])?',line)
                if matchobj:
                    if matchobj.group(4):
                        datatypes.append([matchobj.group(1),matchobj.group(2),matchobj.group(4)])
                    else:
                        datatypes.append([matchobj.group(1),matchobj.group(2),'Bar'])
        except:
            pass
    return datatypes
class gui:
    """Build the base menu to allow the selection of the lake for the DLB
    Lakes are presented in a dropdown menu sorted alphabeticly.  A "Load Entry Sheet" Button
    will launch the DLB Entry Form"""
    def __init__(self):
        self.Lakes = {'Barren':'BRR','Buckhorn':'BHR','Brookville':'BVR',
                      'Caesar Creek':'CCK','Cagles Mill':'CMR','Carr Creek':'CFK','Cave Run':'CRR','C J Brown':'CBR','C M Harden':'CHL',
                      'Green':'GRR','Monroe':'MNR','Nolin':'NRR','Rough':'RRR','Patoka':'PRR',
                      'Taylorsville':'TVL','WestFork':'WFR','W H Harsha':'WHL'}
        self.root = Tk()
        self.root.title('DLB Input Program')
        self.LaunchCanvas = Canvas(self.root)
        w, h = self.root.winfo_screenwidth(), self.root.winfo_screenheight()
        self.root.geometry("%dx%d+-10+0" % (w, h)) 
        self.LaunchCanvas.pack()
        self.tkvar = StringVar(self.root)
        self.tkvar.set('Choose Lake')
        lakesort= list(self.Lakes.keys())
        lakesort.sort()
        helv = tkFont.Font(family='Helvetica', size=24)
        popupMenu1 = OptionMenu(self.LaunchCanvas, self.tkvar, *lakesort)
        popupMenu1.config(font=helv,width=30,height=5)
        self.root.nametowidget(popupMenu1.menuname).config(font=helv)
        popupMenu1.grid(row=0,column = 0, rowspan=2, columnspan=2)
        self.load_status = Label(self.LaunchCanvas,font=("Arial", 24))
        self.load_status.grid(row=5,column=0,columnspan=4)
        Launch = Button(self.LaunchCanvas,text="Load Entry Sheet",command = self.LoadDLB)
        Launch.config(width=45,height=5,bg='light blue',font=helv)
        Launch.grid(row=9, column =0, rowspan=2, columnspan=2)

        self.root.mainloop()
    def getData(self):
        """Retrieve data from USGS using the IDs and store the datestamped values in a dictionary object in the self.Data Object keyed off of the loc/parameter
        """
        self.Data = {}
        code = {'ELEV':'62614','Stage':'00065','Tailwater':'00010=on&cb_00065','Flow':'00060'}
        Tailwater = {'BHR':'','BRR':'03313000','BVR':'03276000','CBR':'03268100','CCK':'03242350','CFK':'03277450',
                     'CHL':'03340900','CMR':'03359000','CRR':'03249500','GRR':'03306000','MNR':'03372500','NRR':'03311000',
                     'PRR':'03374500','RRR':'03318010','TVL':'03295597','WFR':'','WHL':'03247041'}
        self.River_Stations =     {'BHR':['Tallega','Lock 14'],
                              'BRR':['Alvaton','Bowling Green','Lock 4 (Woodbury)'],
                              'BVR':['Alpine','Brookville'],
                              'CBR':['Eagle City','Springfield (Mad R)'],
                              'CCK':['Milford','Spring Valley'],
                              'CFK':['Hazard'],
                              'CHL':['Coxville'],
                              'CMR':['Reelsville','Bowling Green','Spencer'],
                              'CRR':['Farmers','Morehead (TR. C)'],
                              'GRR':['Columbia','Greensburg'],
                              'MNR':['Shoals','Petersburg','Bedford'],
                              'NRR':['Munfordville','Brownsville'],
                              'PRR':['Jasper'],
                              'RRR':['Dundee'],
                              'TVL':['Brashears Creek'],
                              'WFR':['Reading','Carthage'],
                              'WHL':['Perintown']}
        self.OtherStations = {'BRR':['Calhoun'],'NRR':['Lock 4 (Woodbury)','Calhoun'],'RRR':['Lock 4 (Woodbury)','Calhoun'],'GRR':['Munfordville','Lock 4 (Woodbury)','Calhoun'],
                                     'CHL':['Fincastle','Terre Haute','Mt Carmel'],'CMR':['WhiteRiver@Petersburg'],'MNR':['Mt Carmel'],
                                     'BVR':['Cincinnati'],'BHR':['Hyden','Wooten','Cincinnati'],'CBR':[],'CCK':['Cincinnati'],'CFK':['Lock 14'],'CRR':['Salyersville','Blue Lick Springs','Catawba','Cincinnati'],
                                     'PRR':[],'TVL':['Glensboro\nCFS','Shepherdsville'],'WFR':[],'WHL':['Milford','Williamsburg\ncfs','Cincinnati']}

        # limits = [NWS flood stage, WCM (rising) limit] for plot display
        self.limits = {
            'CRR': {
                'Farmers': [None, 12],
                'Blue Lick Springs': [25, 17],
                'Catawba': [33, 19],
                'Cincinnati': [52, 40],
            }
        }

        usgs ={'BHR':'03280800','BRR':'03312900','BVR':'03275990','CBR':'03268090','CCK':'03242340','CFK':'03277446','CHL':'03340870','CMR':'03358900',
               'CRR':'03249498','GRR':'03305990','MNR':'03372400','NRR':'03310900','RRR':'03318005','PRR':'03374498','TVL':'03295597','WFR':'03256500','WHL':'03247040',
               'Hyden':'03280612','Wooten':'03280700','Tallega':'03281000','Lock 14':'03282000',
               'Alvaton':'03314000','Bowling Green KY':'03314500','Lock 4 (Woodbury)':'03315500',
               'Alpine':'03275000','Brookville':'03276500',
               'Eagle City':'03267900','Springfield (Mad R)':'03269500',
               'Milford':'03245500','Spring Valley':'03242050',
               'Hazard':'03277500',
               'Fincastle':'03340800','Ferndale':'03340900','Coxville':'03341300',
               'Reelsville':'03357500','Bowling Green IN':'03360000','Spencer':'03357000',
               'Salyersville':'03248300','Farmers':'03249505','Morehead (TR. C)':'03250100',
               'Greensburg':'03306500','Columbia':'03307000',
               'Shoals':'03282060','Petersburg':'03373980',
               'Munfordville':'03308500','Brownsville':'03311505',
               'Jasper':'03375500',
               'Dundee':'03319000',
               'Brashears Creek':'03295890','Glensboro\nCFS':'03295400',
               'Reading':'03255500','Carthage':'03259000',
               'Perintown':'03247500',
               'Calhoun':'03320000','Terre Haute':'03341500','WhiteRiver@Petersburg':'03374000','Bedford':'03371500','Shepherdsville':'03298500','Blue Lick Springs':'03250500',
               'Catawba':'03253500','Mt Carmel':'03377500','Cincinnati':'03255000','Williamsburg\ncfs':'03246500'}
        locs = []
        for i in range(len(self.River_Stations[self.lkname])):
            locs.append(self.River_Stations[self.lkname][i])
        try:
            for i in range(len(self.OtherStations[self.lkname])):
                if self.OtherStations[self.lkname][i] not in locs:
                    locs.append(self.OtherStations[self.lkname][i])
        except:
            pass
        parameters = ['Stage']* len(locs)
        locs.append(self.lkname)
        locs.append('Tailwater')
        parameters.append('ELEV')
        parameters.append('Tailwater')
        for i in range(len(locs)):
            try:
                self.load_status.configure(text="Getting " + locs[i] + " Data from USGS")
                self.root.update_idletasks()
                url = ""
                if locs[i] == 'Bowling Green':
                    if self.lkname == 'BRR':
                        station = locs[i] + ' KY'
                    elif self.lkname == 'CMR':
                        station = locs[i] + ' IN'
                elif locs[i] in ['Williamsburg\ncfs','Glensboro\nCFS']:
                    parameters[i] = 'Flow'
                    station = locs[i]
                else:
                    station = locs[i]
                if parameters[i] == 'Tailwater':
                    self.Data['Tailwater'] = {}
                    self.Data['WaterTemp'] = {}
                    if Tailwater[self.lkname] != '':
                        url = 'https://waterdata.usgs.gov/nwis/uv?cb_'+code['Tailwater']+'=on&format=rdb&site_no='+Tailwater[self.lkname]+'&period=7'
                else:
                    self.Data[locs[i]] = {}
                    url = 'https://waterdata.usgs.gov/nwis/uv?cb_'+code[parameters[i]]+'=on&format=rdb&site_no='+usgs[station]+'&period=7'
                if len(url) > 0:
                    req = urllib.request.Request(url)
                    response = urllib.request.urlopen(req)
                    html = response.read()
                    html = html.decode('utf8')
                    types = datatypes(html)
                    print (types)
                    if self.lkname == 'TVL':
                        for t in types:
                            if t[2] == '[Tailwater]' and t[1] == '00065':
                                    tail_off = 2*types.index(t)
                            if t[2] == 'Bar' and t[1] == '00010':
                                temp_off = 2*types.index(t)
                    elif self.lkname in ['BVR','CHL']:
                        tail_off,temp_off = 0,2
                    else:
                        if types[0][1] == '00065':
                            tail_off,temp_off = 0,2
                        else:
                            tail_off,temp_off = 2,0
                    
                    for line in html.split('\n'):
                        if parameters[i] == 'Tailwater':
                            if line.split('\t')[0] == 'USGS':
                                try:
                                    self.Data[locs[i]][line.split('\t')[2]] = float(line.split('\t')[4+tail_off])
                                except:
                                    pass
                                try:
                                    self.Data['WaterTemp'][line.split('\t')[2]] = float(line.split('\t')[4+temp_off])
                                except:
                                    pass
                        else:
                            if line.split('\t')[0] == 'USGS':
                                try:
                                    self.Data[locs[i]][line.split('\t')[2]] = float(line.split('\t')[4])
                                except:
                                    pass
            except:
                pass
                        
    def LoadDLB(self):
        self.lkname = self.Lakes[self.tkvar.get()]
        self.getData()
        self.LaunchCanvas.destroy()
        self.Load_DLB_Interface()
         
    def Load_DLB_Interface(self):
        """Gui interface is built dynamiclly using dictionary lookups to setup gate configurations, data validation criteria, and river stations using the lake code as the lookup"""
        self.Elev_Limits = {'BHR':[752,877],'BRR':[523,618],'BVR':[735,775],'CBR':[1004,1040],'CCK':[841,904],'CFK':[1012,1083],'CHL':[635,712],'CMR':[631,730],
                             'CRR':[719,788],'GRR':[663,734],'MNR':[533,574],'NRR':[487,581],'PRR':[527,564],'RRR':[465,554],'TVL':[540,623],'WFR':[670,735.5],'WHL':[724,819]}
        #Upper Elevation is top of Dam
        #Lower Elevation is winter pool -5

        self.Gate_configuration = {'BHR':[('Main Gate','MG1',3),('Bypass 1 Opening','BP1',1),('Bypass 2 Opening','BP2',1)],
                              'BRR':[('Main Gate','MG1',2),('Bypass 1 Opening','BP1',1),('Bypass 2 Opening','BP2',1),('Bypass 1 Level','L1',2),('Bypass 2 Level','L2',2)],
                              'BVR':[('Main Gate','MG1',2),('Bypass 1 Opening','BP1',1),('Bypass 2 Opening','BP2',1),('Bypass 1 Level','L1',6),('Bypass 2 Level','L2',6)],
                              'CBR':[('Main Gate','MG1',2),('Bypass 1 Opening','BP1',1),('Bypass 2 Opening','BP2',1)],
                              'CCK':[('Main Gate','MG1',2),('Bypass 1 Opening','BP1',1),('Bypass 2 Opening','BP2',1),('Bypass 1 Level','L1',4),('Bypass 2 Level','L2',4)],
                              'CFK':[('Main Gate','MG1',2),('Bypass 1 Opening','BP1',1),('Bypass 2 Opening','BP2',1),('Bypass 1 Level','L1',3),('Bypass 2 Level','L2',3)],
                              'CHL':[('Main Gate','MG1',3),('Bypass 1 Opening','BP1',1),('Bypass 2 Opening','BP2',1)],
                              'CMR':[('Main Gate','MG1',1),('Bypass 1 Opening','BP1',1)],
                              'CRR':[('Main Gate','MG1',2),('Bypass 1 Opening','BP1',1),('Bypass 2 Opening','BP2',1),('Bypass 1 Level','L1',3),('Bypass 2 Level','L2',3)],
                              'GRR':[('Main Gate','MG1',3),('Bypass 1 Opening','BP1',1),('Bypass 2 Opening','BP2',1),('Bypass 1 Level','L1',9),('Bypass 2 Level','L2',9)],
                              'MNR':[('Main Gate','MG1',2),('Bypass 1 Opening','BP1',1),('Bypass 2 Opening','BP2',1),('Bypass 1 Level','L1',7),('Bypass 2 Level','L2',7)],
                              'NRR':[('Main Gate','MG1',3),('Bypass 1 Opening','BP1',1),('Bypass 2 Opening','BP2',1),('Bypass 1 Level','L1',3),('Bypass 2 Level','L2',3)],
                              'PRR':[('Main Gate','MG1',0,2),('Bypass 1 Opening','BP1',0,1),('Bypass 2 Opening','BP2',0,1),('Bypass 1 Level','L1',1,3),('Bypass 2 Level','L2',4,6)],
                              'RRR':[('Main Gate','MG1',2),('Bypass 1 Opening','BP1',1),('Bypass 2 Opening','BP2',1)],
                              'TVL':[('Service Gate 1','MG1',0.6),('Bypass 1 Opening','BP1',1),('Bypass 1 Level','L1',9),('Service Gate 2','MG2',0.6),('Bypass 2 Opening','BP2',1),('Bypass 2 Level','L2',9)],
                              'WFR':[('Main Gate','MG1',3),('Bypass 1 Opening','BP1',1)],
                              'WHL':[('Main Gate','MG1',2),('Bypass 1 Opening','BP1',1),('Bypass 2 Opening','BP2',1),('Bypass 1 Level','L1',5),('Bypass 2 Level','L2',5)]}

        self.Validating = False
        newWindow = Frame(self.root)
        newWindow.pack()
        self.infobox = Label(newWindow,font=("Arial", 10))
        self.infobox.grid(row=4,column=12,rowspan=2,columnspan=3)
        self.recheck = False
        self.flow = ratings.GateRatingSet(self.lkname)
        
        gate_settings_frame = self.build_gate_settings_frame(newWindow)
        gate_settings_frame.grid(row=0, column=0, columnspan=4, padx=5, pady=5, sticky='nsew')
        
        pool_change_frame = self.build_pool_change_frame(newWindow)
        precip_frame = self.build_precip_frame(newWindow)
        weather_frame = self.build_weather_frame(newWindow)
        weather_frame.grid_propagate(0)  # Fixed width to prevent GUI "bouncing"
        temperature_frame = self.build_temperature_frame(newWindow)
        for i, frame in enumerate([pool_change_frame, precip_frame, weather_frame, temperature_frame]):
            frame.grid(row=1, column=i, padx=5, pady=5, sticky='nsew')

        anticipated_frame = self.build_anticipated_frame(newWindow)
        river_stations_frame = self.build_river_stations_frame(newWindow)
        for i, frame in enumerate([anticipated_frame, river_stations_frame]):
            frame.grid(row=2, column=i*2, columnspan=2, padx=5, pady=5, sticky='nsew')  

        remarks_frame = self.build_remarks_frame(newWindow)
        remarks_frame.grid(row=3, column=0, columnspan=4, padx=5, pady=5, sticky='nsew')

        cp_plots_frame = self.build_cp_plots_frame(newWindow)
        cp_plots_frame.grid(row=4, column=0, columnspan=4, padx=5, pady=5, sticky='nsew')

        header_frame = self.build_header_frame(newWindow)
        header_frame.grid(row=0, column=4, padx=5, sticky='nsew')
        project_plots_frame = self.build_project_plots_frame(newWindow)
        project_plots_frame.grid(row=1, column=4, rowspan=4, padx=5, pady=5, sticky='nsew')

        self.Load()

    def build_gate_settings_frame(self, parent: Widget):
        """Returns a DlbLabelFrame containing the gate setting entry fields.
        Default columns include Date, Time, Elevation, and Tailwater. These columns
        are automatically populated using USGS data when possible. Gate setting
        columns are added according to the self.Gate_configuration dictionary. An
        outflow column displays computed values based on a ratings lookup once gate
        settings data is entered.
        Four rows (1200, 1800, 2400, and 0600) are displayed by default. "Add Gate
        Change" and "Remove Gate Change" buttons are provided to add or remove
        rows as needed to account for gate changes outside the four normal times.
        Args:
            parent: The parent frame of the gate_settings_frame.
        """
        lkname = self.lkname
        gate_settings_frame = DlbLabelFrame(parent, 'Gate Settings')
        Label(gate_settings_frame,text ="Date").grid(row = 0, column = 0)
        Label(gate_settings_frame,text ="Time").grid(row = 0, column = 1)
        Label(gate_settings_frame,text ="Elevation").grid(row = 0, column = 2)
        Label(gate_settings_frame,text ="Tailwater").grid(row = 0, column = 3)
        r,c = 0,4
        for i in range(len( self.Gate_configuration[lkname])):
            Label(gate_settings_frame,text= self.Gate_configuration[lkname][i][0]).grid(row=r,column=c)
            c+=1
        self.DateF = []
        self.TimeF = []
        self.ElevF = []
        self.TailWaterF = []
        self.Entry_dates = []
        for i in range(30):
            year,month,day,hour,Min,sec,wd,yd,dst = time.gmtime(time.time()-i*60*60*24)
            self.Entry_dates.append(str(month)+'/'+str(day)+'/'+str(year))
        year,month,day,hour,Min,sec,wd,yd,dst = time.gmtime()
        self.TkDate = StringVar(gate_settings_frame)
        self.TkDate.set(str(month)+'/'+str(day)+'/'+str(year))
        self.Date = self.TkDate.get()
        self.TkDate.trace('w', self.Load)
        self.gates = []
        self.FlowL = []
        for j in range(len( self.Gate_configuration[lkname])):
            self.gates.append([])
        for i in range(20):
            self.DateF.append(Label(gate_settings_frame))
            self.TimeF.append(Entry(gate_settings_frame, width=10))
            self.TimeF[i].bind('<FocusOut>',self.Validate_time)
            self.ElevF.append(Entry(gate_settings_frame, width=10))
            self.ElevF[i].bind('<FocusOut>',self.Validate)
            self.TailWaterF.append(Entry(gate_settings_frame, width=10))
            self.TailWaterF[i].bind('<FocusOut>',self.Validate)
            for j in range(len( self.Gate_configuration[lkname])):
                self.gates[j].append(Entry(gate_settings_frame, width=10))
                self.gates[j][i].bind('<FocusOut>',self.Validate)
            self.FlowL.append(Label(gate_settings_frame))
        Label(gate_settings_frame,text="Outflow (cfs)").grid(row=0,column=j+5)
        for i in range(j+6):
            gate_settings_frame.columnconfigure(i, minsize=50, weight=1)

        self.gate_buttons_frame = Frame(gate_settings_frame)
        add_gate_button = Button(self.gate_buttons_frame, text="Add Gate Change", command=self.AddGateRow)
        remove_gate_button = Button(self.gate_buttons_frame, text="Remove Gate Change",command=self.RemoveGateRow)
        add_gate_button.grid(row=0, column=0, padx=(20, 0))
        remove_gate_button.grid(row=0, column=1, padx=(20, 0))

        self.numrows = 0
        for i in range(4):
            self.AddGateRow()
        return gate_settings_frame
        
    def AddGateRow(self):
        """Adds a row of gate setting entry fields in the gate settings frame."""
        if self.numrows < 20:
            self.DateF[self.numrows].grid(row=self.numrows+1,column=0)
            self.TimeF[self.numrows].grid(row=self.numrows+1,column=1)
            self.ElevF[self.numrows].grid(row=self.numrows+1,column=2)
            self.TailWaterF[self.numrows].grid(row=self.numrows+1,column=3)
            for j in range(len( self.Gate_configuration[self.lkname])):
                self.gates[j][self.numrows].grid(row=self.numrows+1,column=j+4)
            self.FlowL[self.numrows].grid(row=self.numrows+1,column=j+5)
            self.gate_buttons_frame.grid(row=self.numrows+2, column=0, columnspan=j+6, pady=(10, 0), sticky='nsew')
            if self.numrows >= 4 and self.Validating:
                self.TimeF[self.numrows].focus_set()
            self.numrows += 1
            self.gate_rows = list(zip(
                self.TimeF,
                self.ElevF,
                self.TailWaterF,
                *self.gates,
            ))
            
    def RemoveGateRow(self):
        if self.numrows > 4:
            self.numrows -= 1
            self.DateF[self.numrows].configure(text='')
            self.TimeF[self.numrows].delete(0,"end")
            self.ElevF[self.numrows].delete(0,"end")
            self.TailWaterF[self.numrows].delete(0,"end")
            self.FlowL[self.numrows].grid_remove()
            self.DateF[self.numrows].grid_remove()
            self.TimeF[self.numrows].grid_remove()
            self.ElevF[self.numrows].grid_remove()
            self.TailWaterF[self.numrows].grid_remove()
            for j in range(len( self.Gate_configuration[self.lkname])):
                self.gates[j][self.numrows].delete(0,"end")
                self.gates[j][self.numrows].grid_remove()
            self.FlowL[self.numrows].grid_remove()
            self.gate_buttons_frame.grid(row=self.numrows+2, column=0, columnspan=j+6, pady=(10, 0), sticky='nsew')
            if self.numrows >= 4 and self.Validating:
                self.TimeF[self.numrows].focus_set()
            self.gate_rows = list(zip(
                self.TimeF,
                self.ElevF,
                self.TailWaterF,
                *self.gates,
            ))

    def layout_entry_grid(self, parent: Widget, entry_pairs: List[Tuple[str, Widget]]):
        """Organizes labeled elements into a 2-row horizontal grid.
        Provided elements will be placed on a 2xX grid with labels on the top row
        and widgets on the bottom row.  Label strings will be converted to Label or
        EntryLabel (Message) widgets depending on whether they contain multiple
        words.
        It is assumed that the parent frame will be empty except for the gridded
        objects.  This function will ignore any previously-placed elements.
        However, additional elements may be placed after this function is used.
        Args:
            parent: The frame containing the grid objects.
            entry_pairs: A list of tuples with each tuple representing a label/widget
                pair. Labels should be provided as strings and widgets should be
                provided as the objects themselves.
        """
        for i, (label_text, entry) in enumerate(entry_pairs):
            if ' ' not in label_text:
                label = Label(parent, text=label_text, justify=CENTER)
            else:
                label = EntryLabel(parent, label_text)
            label.grid(row=0, column=i, sticky="n")
            entry.grid(row=1, column=i, sticky="s")
            parent.columnconfigure(i, minsize=50, weight=1)
        parent.rowconfigure(0, weight=1)

    def build_pool_change_frame(self, parent: Widget):
        """Returns a DlbLabelFrame containing the 24-hour pool change entry field.
        Args:
            parent: The parent frame of the pool_change_frame.
        """
        pool_change_frame = DlbLabelFrame(parent, 'Pool')
        self.change = Entry(pool_change_frame, width=7)
        self.layout_entry_grid(
            pool_change_frame,
            [
                ("24-Hour Change", self.change),
            ]
        )
        return pool_change_frame

    def build_precip_frame(self, parent: Widget):
        """Returns a DlbLabelFrame containing the precipitation data entry fields.
        Entry fields included in this frame are 24-Hour Depth, Snow On Ground, and
        Snow Water Content.
        Args:
            parent: The parent frame of the precip_frame.
        """
        precip_frame = DlbLabelFrame(parent, 'Precipitation')
        self.precip = Entry(precip_frame, width=7)
        self.snow = Entry(precip_frame, width=7)
        self.swe = Entry(precip_frame, width=7)
        self.layout_entry_grid(
            precip_frame,
            [
                ("24-Hour Depth", self.precip),
                ("Snow On Ground", self.snow),
                ("Snow Water Content", self.swe),
            ]
        )
        for entry in [self.precip, self.snow, self.swe]:
            entry.bind('<FocusOut>', self.Validate)
        return precip_frame

    def build_weather_frame(self, parent: Widget):
        """Returns a DlbLabelFrame containing the weather data selection box.
        The weather entry is a drop-down selection (OptionMenu) containing the options
        listed in the weather_conditions list object defined within this method.
        Args:
            parent: The parent frame of the weather_frame.
        """
        weather_frame = DlbLabelFrame(parent, 'Weather', width=150)
        self.weather = StringVar(weather_frame)
        self.weather.set('Select Weather')
        weather_conditions = ['Clear','Fair','Hazy','Fog','Partly Cloudy','Cloudy','Drizzle','Light Rain','Rain','Showers','Thunderstorms','Sleet','Freezing Rain','Light Snow','Snow','Blowing Snow','Dust Storm']
        weather_menu = OptionMenu(weather_frame, self.weather, *weather_conditions)
        self.layout_entry_grid(
            weather_frame,
            [
                ("Present Weather", weather_menu),
            ]
        )
        weather_frame.columnconfigure(0, weight=1)
        return weather_frame

    def build_temperature_frame(self, parent: Widget):
        """Returns a DlbLabelFrame containing the temperature data entry fields.
        Entry fields included in this frame are Current Temperature, Minimum
        Temperature, Maximum Temperature, and Tailwater Temperature.
        Args:
            parent: The parent frame of the temperature_frame.
        """
        temperature_frame = DlbLabelFrame(parent, 'Temperature')
        self.curTemp = Entry(temperature_frame, width=7)
        self.maxTemp = Entry(temperature_frame, width=7)
        self.minTemp = Entry(temperature_frame, width=7)
        self.tailTemp = Entry(temperature_frame, width=7)
        deg = u'\N{DEGREE SIGN}'
        self.layout_entry_grid(
            temperature_frame,
            [
                ("Current", self.curTemp),
                ("Max", self.maxTemp),
                ("Min", self.minTemp),
                (f"Tailwater ({deg}C)", self.tailTemp),
            ]
        )
        for entry in [self.curTemp, self.maxTemp, self.minTemp, self.tailTemp]:
            entry.bind('<FocusOut>', self.Validate)
        return temperature_frame

    def build_anticipated_frame(self, parent: Widget):
        """Returns a DlbLabelFrame containing the anticipated gate setting fields.
        Entry fields are dynamically generated based on the gate configuration
        defined in self.Gate_configuration for the active project.  Once gate
        settings have been provided, the outflow label will display the anticipated
        outflow based on the available gate ratings data.
        Args:
            parent: The parent frame of the ancitipated_frame.
        """
        anticipated_frame = DlbLabelFrame(parent, "Anticipated Settings (Next 0600)")
        gate_pairs = []
        self.a_gates = []
        for i, gate in enumerate(self.Gate_configuration[self.lkname]):
            label = gate[0]
            entry = Entry(anticipated_frame, width=7)
            self.a_gates.append(entry)
            gate_pairs.append((label, entry))
        self.A_FlowL = Label(anticipated_frame)
        gate_pairs.append(("Outflow (cfs)", self.A_FlowL))
        self.layout_entry_grid(anticipated_frame, gate_pairs)
        for label, entry in gate_pairs:
            entry.bind('<FocusOut>', self.Validate)
        return anticipated_frame

    def build_river_stations_frame(self, parent: Widget):
        """Returns a DlbLabelFrame containing the river station stage fields.
        Entry fields are dynamically generated based on the stations defined in
        self.River_Stations for the active project.  Labels are generated for the
        stations listed in self.OtherStations for the active project, with
        corresponding stages displayed based on available USGS data.
        Args:
            parent: The parent frame of the river_stations_frame.
        """
        river_stations_frame = DlbLabelFrame(parent, "River Stations")
        self.r_station = []
        station_pairs = []
        for station_name in self.River_Stations[self.lkname]:
            entry = Entry(river_stations_frame, width=7)
            station_pairs.append((station_name, entry))
            self.r_station.append(entry)
        mon,day,year = self.Date.split('/')
        datetime_str = year + '-' + pad(mon,2,'0') + '-'+pad(day,2,'0') + ' 06:00'
        for station_name in self.OtherStations[self.lkname]:
            try:
                stage = str(self.Data[station_name][datetime_str])
            except:
                stage = ""
            stage_label = Label(river_stations_frame, text=stage)
            station_pairs.append((station_name, stage_label))
        self.layout_entry_grid(river_stations_frame, station_pairs)
        return river_stations_frame
    
    def build_remarks_frame(self, parent: Widget):
        """Returns a DlbLabelFrame containing the remarks entry field.
        Args:
            parent: The parent frame of the remarks_frame.
        """
        remarks_frame = DlbLabelFrame(parent, "Remarks")
        remarks_label = Label(remarks_frame, text="Remarks:")
        remarks_label.grid(row=0,column=0)
        self.remarks = Entry(remarks_frame, width=77)
        self.remarks.grid(row=0, column=1)
        return remarks_frame

    def build_cp_plots_frame(self, parent):
        """Returns a DlbLabelFrame containing the control point plots.
        A standard line plot is generated for each station listed in the
        self.River_Stations and self.OtherStations lists for the active project.
        Plots are arranged horizontally and weighted equally.  If stage limits
        are displayed on plots, rows containing legend labels are added beneath
        the plots row.
        Args:
            parent: The parent frame of the cp_plots_frame.
        """
        cp_plots_frame = DlbLabelFrame(parent, "Control Point Plots")
        stations = self.River_Stations[self.lkname] + self.OtherStations[self.lkname]
        for i, station in enumerate(stations):
            limits = None
            if self.lkname in self.limits:
                if station in self.limits[self.lkname]:
                    limits = self.limits[self.lkname][station]
            plot = build_plot(cp_plots_frame, self.Data[station], station, limits)
            plot.get_tk_widget().grid(row=0, column=i, padx=5)
            cp_plots_frame.columnconfigure(i, weight=1)
        if self.lkname in self.limits:
            wcm_note = "Black (dotted) line: Water Control Manual operational limit.  Flood setting should be used if stage is above this limit and rising unless directed otherwise by Water Management."
            wcm_label = Label(cp_plots_frame, text=wcm_note)
            wcm_label.grid(row=1, column=0, columnspan=len(stations))
            nws_note = "Red (dashed) line: National Weather Service flood stage."
            nws_label = Label(cp_plots_frame, text=nws_note)
            nws_label.grid(row=2, column=0, columnspan=len(stations))
            
        cp_plots_frame.rowconfigure(0, weight=1)
        return cp_plots_frame

    def build_header_frame(self, parent):
        """Returns a Frame containing the main header info and controls.
        The header frame contains a Label of the 3-letter code for the active
        project, a date selection box OptionMenu, and a submit Button.
        Args:
            parent: The parent frame of the header_frame.
        """
        header_frame = Frame(parent, padx=5, pady=10)
        project_label = Label(header_frame, text=self.lkname, font=("Arial", 25))
        project_label.grid(row=0, column=0, pady=(20, 10))
        helv = tkFont.Font(family='Helvetica', size=18)
        date_dropdown = OptionMenu(header_frame, self.TkDate, *self.Entry_dates)
        date_dropdown.config(font=helv)
        date_dropdown.grid(row=1, column=0, pady=(10, 10))
        self.root.nametowidget(date_dropdown.menuname).config(font=helv)
        submit_button = Button(header_frame, text="Submit", command=self.Submit)
        submit_button.config(width=10, height=2, bg='light blue',font=helv)
        submit_button.grid(row=2, column=0, pady=(10, 10))
        header_frame.columnconfigure(0, weight=1)
        return header_frame

    def build_project_plots_frame(self, parent):
        """Returns a DlbLabelFrame containing the elevation and tailwater plots.
        Plots are arranged vertically and weighted equally.
        Args:
            parent: The parent frame of the project_plots_frame.
        """
        project_plots_frame = DlbLabelFrame(parent, "Project Plots")
        elev_plot = build_plot(project_plots_frame, self.Data[self.lkname], f'{self.lkname} Pool Elevation')
        tw_plot = build_plot(project_plots_frame, self.Data['Tailwater'], f'{self.lkname} Tailwater')
        for i, plot in enumerate([elev_plot, tw_plot]):
            plot.get_tk_widget().grid(row=i, column=0)
            project_plots_frame.rowconfigure(i, weight=1)
        project_plots_frame.columnconfigure(0, weight=1)
        return project_plots_frame
        
    def Submit(self):
        """Submit first runs the find_submit_errors function and displays the error if one is found.
        If no errors it itterates through the entry objects to pruduce the output file.
        The output file is then copied and date stamped for archiving
        Finally the send.bat is called to transfer the files to the server."""
        err = self.find_submit_errors()
        try:
            x0,y0,x1,y1 = self.root.winfo_rootx(),self.root.winfo_rooty(),self.root.winfo_rootx()+self.root.winfo_width(),self.root.winfo_rooty()+self.root.winfo_height()
            im = ImageGrab.grab()
            im.save('//COE-LRLDFE01LOU/ORG/ED/Public/DLB/dlbpy/Captured/'+self.lkname+'.jpg')
            self.infobox.configure(text="Submission Started")
            self.root.update_idletasks()     
        except:
            pass
        if err:
            mb.showwarning("Submission Halted Due to Error",err+'\nPlease Correct and resubmit')
            return False
        year,month,day,hour,Min,sec,wd,yd,dst = time.localtime()
        Modtime = str(year)+pad(str(month),2,'0')+pad(str(day),2,'0')+pad(str(hour),2,'0')+pad(str(Min),2,'0')
        basin = GetBasin(self.lkname)
        f = open('o:/ED/PUBLIC/DLB/OUTPUT/'+self.lkname+'pydlb.txt','w')
        f.write(basin + ' ' + self.lkname + ' ' + self.Date +' 0000 MODTIME:' + Modtime + '\n')
        f.write('#Lake Levels and Gate Setting\n')
        for i in range(20):
            if self.DateF[i]['text']:
                if self.TimeF[i].get():
                    if self.ElevF[i].get():
                        gatesComplete = True
                        for j in range(len(self.Gate_configuration[self.lkname])):
                            if self.gates[j][i].get():
                                pass
                            else:
                                gatesComplete = False
                        if gatesComplete:
                            f.write(basin + ' ' + self.lkname + ' ' + self.DateF[i]['text'] + ' ' + self.TimeF[i].get() +' ELEV :' + self.ElevF[i].get() +'\n')
                            if self.TailWaterF[i].get():
                                f.write(basin + ' ' + self.lkname + ' ' + self.DateF[i]['text'] + ' ' + self.TimeF[i].get() +' TAILWATER :' + self.TailWaterF[i].get() +'\n')
                            for j in range(len(self.Gate_configuration[self.lkname])):
                                f.write(basin + ' ' + self.lkname + ' ' + self.DateF[i]['text'] + ' ' + self.TimeF[i].get() + ' ' +  self.Gate_configuration[self.lkname][j][1] + ' :' + self.gates[j][i].get() + '\n')
        f.write('#Anticipateed and Gate Setting\n')
        for i in range(len(self.a_gates)):
            f.write(basin + ' ' + self.lkname + ' ' + self.Date + ' 0600 ' + self.Gate_configuration[self.lkname][i][1][:-1] + '_ANTICIPATED_' + self.Gate_configuration[self.lkname][i][1][-1] + ' :' + self.a_gates[i].get() + '\n')
        f.write('#Weather\n')
        f.write(basin + ' ' + self.lkname + ' ' + self.Date + ' 0600 CHANGE :' + self.change.get() +'\n')
        f.write(basin + ' ' + self.lkname + ' ' + self.Date + ' 0600 AMTRAIN :' + self.precip.get() +'\n')
        f.write(basin + ' ' + self.lkname + ' ' + self.Date + ' 0600 SNOW :' + self.snow.get() +'\n')
        f.write(basin + ' ' + self.lkname + ' ' + self.Date + ' 0600 SNOWWATER :' + self.swe.get() + '\n')
        f.write(basin + ' ' + self.lkname + ' ' + self.Date + ' 0600 PRESWEATHR :' + self.weather.get() + '\n')
        f.write(basin + ' ' + self.lkname + ' ' + self.Date + ' 0600 AIR :' + self.curTemp.get() + '\n')
        f.write(basin + ' ' + self.lkname + ' ' + self.Date + ' 0600 MAX :' + self.maxTemp.get() + '\n')
        f.write(basin + ' ' + self.lkname + ' ' + self.Date + ' 0600 MIN :' + self.minTemp.get() + '\n')
        if self.tailTemp.get() != '-901':
            f.write(basin + ' ' + self.lkname + ' ' + self.Date + ' 0600 WATERTEMP :' + self.tailTemp.get() + '\n')
        f.write('#DownStream Stations\n')
        for i in range(len(self.r_station)):
            if float(self.r_station[i].get()) != 0.0:
                value = self.r_station[i].get()
            else:
                value = "-901"
            f.write(basin + ' ' + self.lkname + ' ' + self.Date + ' 0600 ' +  self.River_Stations[self.lkname][i] + ' :' + value + '\n')
        f.write('#Remarks\n')
        f.write(basin + ' ' + self.lkname + ' ' + self.Date + ' 0600 REMARKS :' + self.remarks.get() + '\n')
        f.flush()
        f.close()
        os.system('copy o:\\ed\\public\\dlb\\output\\' + self.lkname+'pydlb.txt o:\\ed\\public\\dlb\\archive\\' +self.lkname+'pydlb'+self.Date.replace('/','-')+'.txt')
        self.infobox.configure(text="Starting Transfer to WM's Server")
        self.root.update_idletasks()
        f2 = open(r'c:\temp\send.txt','w')
        f2.write(r"""option batch abort
option confirm off
lcd c:\temp
open h2ssha09@coe-lrluwa04lrl.lrl.ds.usace.army.mil -privatekey=ssh.ppk -hostkey="ssh-rsa 2048 f5:5b:a1:aa:7a:7a:54:a9:7f:30:08:f5:13:ad:1c:32"
option transfer ascii
lcd o:\ed\public\dlb\output
cd dlbfiles
synchronize remote
close
exit""")
        f2.flush()
        f2.close()
        f3 = open(r"c:\temp\send.bat",'w')
        f3.write(r"""@echo off
net use x: /delete /y
net use x: \\coe-lrldfe01lou\org
copy x:\ed\public\dlb\database\extract\ssh.ppk c:\temp
c:
cd \temp
certutil -hashfile "winscp.exe" > "c:\temp\winscp_exe.hash"
fc c:\temp\winscp_exe.hash x:\ed\public\dlb\database\extract\winscp_exe.hash || copy x:\ed\public\dlb\database\extract\winscp.exe c:\temp\winscp.exe
certutil -hashfile "winscp.com" > "c:\temp\winscp_com.hash"
fc c:\temp\winscp_com.hash x:\ed\public\dlb\database\extract\winscp_com.hash || copy x:\ed\public\dlb\database\extract\winscp.com c:\temp\winscp.com
certutil -hashfile "winscp.ini" > "c:\temp\winscp_ini.hash"
fc c:\temp\winscp_ini.hash x:\ed\public\dlb\database\extract\winscp_ini.hash || copy x:\ed\public\dlb\database\extract\winscp.ini c:\temp\winscp.ini
winscp.com /console /script=send.txt
rm ssh.ppk
""")
        f3.flush()
        f3.close()
        os.system(r'c:\temp\send.bat')
        self.infobox.configure(text="")
        self.root.update_idletasks()
        path = r"O:\ED\Public\DLB\Archive"
        now = time.time()
        for f in os.listdir(path):
            if os.stat(os.path.join(path,f)).st_mtime < now - 30 * 86400:
                os.remove(os.path.join(path,f))
        osh = mb.askyesno(title="DLB Submission Complete", message="Open Screenshot")
        if osh:
            f_name = filedialog.asksaveasfilename(parent=self.root,title='Save DLB Sheet as PDF',initialdir=os.path.expanduser('~')+'\\Documents\\',initialfile=self.lkname+'DLB.pdf',filetypes=[('PDF','.pdf'),],defaultextension=['.pdf'])
            im.save(f_name)
            os.system(f_name)
        return True

    def find_submit_errors(self) -> str:
        """Checks for data entry errors before DLB is processed.
        Returns:
            str: A string containing an error message for the first error discovered,
                or a blank string if no errors are found.
        """
        check_functions = [
            self.check_required_fields,
            self.check_additional_gate_entries,
            self.check_temperature_values,
        ]
        for check_function in check_functions:
            check_error = check_function()
            if check_error:
                return check_error
        return ''

    def check_required_fields(self) -> str:
        """Checks for entered values in every required field.
        Returns:
            str: A string containing an error message listing some or all of the
                missing fields, or a blank string if no required fields are missing.
        """
        i = 0
        for row in self.gate_rows[:4]:  # 1200, 1800, 2400, and 0600
            if not all(entry.get() for entry in row):
                return f'Missing value(s) in gate table at {self.DateF[i]["text"]} on {row[1].get()}\nAll gate settings must be filled in.\nPlease fill in missing setting for this row.'
                i += 1
        required_fields = [
            ["24-Hour Pool Change", self.change],
            ["24-Hour Precip", self.precip],
            ["Snow on Ground", self.snow],
            ["Snow Water Content", self.swe],
            ["Current Temperature", self.curTemp],
            ["Min. Temperature", self.minTemp],
            ["Max. Temperature", self.maxTemp],
            ["Tailwater Temperature", self.tailTemp],
        ]
        for i, station in enumerate(self.River_Stations[self.lkname]):
            required_fields.append([f'{station} Stage', self.r_station[i]])
        for i, gate in enumerate(self.Gate_configuration[self.lkname]):
            required_fields.append([f'Ant. {gate[0]}', self.a_gates[i]])
        missing_fields = [x[0] for x in required_fields if x[1].get() == '']
        if self.weather.get() == 'Select Weather':
            missing_fields.append('Present Weather')
        if float(self.snow.get()) < float(self.swe.get()):
            return f'Snow Water Content cannot be greater than Snow On Ground'
        if missing_fields:
            return f'The following required fields are missing: {missing_fields}'
        return ''

    def check_additional_gate_entries(self) -> str:
        """Checks that all additional gate entry rows have complete data.
        Returns:
            str: A string containing an error message indicating the gate entry row
                containing incomplete data, or a blank string if no incomplete gate
                entry rows are found.
        """
        for i, row in enumerate(self.gate_rows[4:]):
            if any([x.get() for x in row]) and not all(x.get() for x in row):
                return f'Incomplete data entered for gate entry row #{i + 5}'
        return ''

    def check_temperature_values(self) -> str:
        """Checks that temperature values are entered correctly.
        Returns:
            str: A string containing an error message or an empty string if no
                errors are found.
        """
        if float(self.maxTemp.get()) < float(self.minTemp.get()):
            return 'Temp: Min greater than max'
        if not float(self.minTemp.get()) <= float(self.curTemp.get()) <= float(self.maxTemp.get()):
            return 'Temp: Current not between min and max'
        return ''

    def Validate_time(self,event):
        """The time is checked using a regular expression.  If the time is not valid an error is displayed.
        If the time is valid the date for that row is set to the appropreate date"""
        times = ['1200','1800','2400','0600']
        if self.Validating:
            if self.TimeF.index(event.widget) <=3:
                i = self.TimeF.index(event.widget)
                self.TimeF[i].delete(0,'end')
                self.TimeF[i].insert(0,times[i])
            tm = re.compile("([01]?[0-9]|2[0-3])[0-5][0-9]")
            if event.widget.get() != "":
                if tm.match(event.widget.get()):
                    if int(event.widget.get()) > 600:
                        year,month,day,hour,Min,sec,wd,yd,dst = time.gmtime(time.time()-(self.Entry_dates.index(self.Date)+1)*60*60*24)
                        yesterday = str(month)+'/'+str(day)+'/'+str(year)
                        self.DateF[self.TimeF.index(event.widget)].configure(text=yesterday)
                    else:
                        self.DateF[self.TimeF.index(event.widget)].configure(text=self.Date)
                    for i in range(len(self.TimeF)):
                        if self.TimeF[i] != event.widget and pad(event.widget.get(),4,'0') == pad(self.TimeF[i].get(),4,'0'):
                            mb.showwarning("","Times must be unique")
                            event.widget.focus_set()
                            return
                    if event.widget.get() == '2400':
                        mon,day,year = self.Date.split('/')
                        h,m = '00','00'
                    else:
                        mon,day,year = self.DateF[self.TimeF.index(event.widget)]['text'].split('/')
                        h,m = int(int(event.widget.get())/100), int(event.widget.get())%100
                    self.ElevF[self.TimeF.index(event.widget)].delete(0,"end")
                    self.ElevF[self.TimeF.index(event.widget)].insert(0,Interpolate(self.Data[self.lkname],year+'-'+pad(mon,2,'0')+'-'+pad(day,2,'0') + ' '+pad(str(h),2,'0')+':'+pad(str(m),2,'0')))
                    self.TailWaterF[self.TimeF.index(event.widget)].delete(0,"end")
                    self.TailWaterF[self.TimeF.index(event.widget)].insert(0,Interpolate(self.Data['Tailwater'],year+'-'+pad(mon,2,'0')+'-'+pad(day,2,'0') + ' '+pad(str(h),2,'0')+':'+pad(str(m),2,'0')))
                else:
                    mb.showwarning("","Time is not in hhmm format")
                    event.widget.focus_set()
            else:
                return

    def Validate(self,event):
        """Values for entry objects are checked against the criteria for their given bounds.
        First the entry object in question is checked against the arrays of objects to establish what type of entry ojbect it is.
        Then the min and max values are set accordingly
        If the value is outside of the bound an error is displayed.
        Finally if the value cannot be evaluated because it isn't the right datatype an error message indicating the value is not a number"""
        if self.Validating:
            try:
                Name = ""
                stop = True
                index = -901
                if not (event.widget.get() == '') and not self.recheck:
                    if event.widget in self.ElevF:
                        min_val, max_val = self.Elev_Limits[self.lkname]
                        index = self.ElevF.index(event.widget)
                        Name = "Elevation @ " + self.TimeF[index].get()
                        if index == 3:
                            try:
                                mon,day,year = self.DateF[0]['text'].split('/')
                                chg = float(self.ElevF[3].get()) - float(self.Data[self.lkname][year+'-'+pad(mon,2,'0')+'-'+pad(day,2,'0') + ' 06:00'])
                                self.change.delete(0,"end")
                                self.change.insert(0,str(round(chg,2)))
                            except:
                                pass
                    if event.widget in self.TailWaterF:
                        min_val, max_val = 0,float(self.ElevF[self.TailWaterF.index(event.widget)].get())
                    for i in range(len(self.Gate_configuration[self.lkname])):
                        if event.widget in self.gates[i]:
                            if self.lkname == 'PRR':
                                min_val,max_val=float(self.Gate_configuration[self.lkname][i][2]),float(self.Gate_configuration[self.lkname][i][3])
                                if self.Gate_configuration[self.lkname][i][1][0] == 'L':
                                    if int(event.widget.get()) == 0:
                                        return
                            else:
                                min_val,max_val = 0,float(self.Gate_configuration[self.lkname][i][2])
                            index = self.gates[i].index(event.widget)
                            Name = self.Gate_configuration[self.lkname][i][1] + " @ " + self.TimeF[index].get()
                            if self.Gate_configuration[self.lkname][i][1][0] == 'M' and self.lkname not in ['CMR','CHL']:
                                try:
                                    if float(event.widget.get()) > 0:
                                        for j in range(len(self.Gate_configuration[self.lkname])):
                                            if self.Gate_configuration[self.lkname][j][1][0] == 'B' and float(self.gates[j][index].get()) > 0:
                                                self.recheck = True
                                                mb.showwarning("Odd Gate Setting","It's Unusal to have Main Gate and Bypasses both open")
                                except:
                                    pass
                            if self.Gate_configuration[self.lkname][i][1][0] == 'B' and self.lkname != 'TVL':
                                if float(event.widget.get()) == 0.0:
                                    for j in range(len(self.Gate_configuration[self.lkname])):
                                        if self.Gate_configuration[self.lkname][j][1][0] == 'L':
                                            if self.Gate_configuration[self.lkname][j][1][-1] == self.Gate_configuration[self.lkname][i][1][-1]:
                                                self.gates[j][index].delete(0,'end')
                                                self.gates[j][index].insert(0,'0')
                                if float(event.widget.get()) > 0:
                                    for j in range(len(self.Gate_configuration[self.lkname])):
                                        if self.Gate_configuration[self.lkname][j][1][0] == 'M' and self.lkname not in ['CMR','CHL']:
                                            try:
                                                if float(self.gates[j][index].get()) > 0:
                                                    self.recheck = True
                                                    mb.showwarning("Odd Gate Setting","It's Unusal to have Main Gate and Bypasses both open")
                                            except:
                                                pass
                            if self.Gate_configuration[self.lkname][i][1][0] == 'L':
                                try:
                                    int(event.widget.get())
                                except:
                                    self.recheck = True
                                    mb.showwarning(Name + " Entry Not Valid","Must be an integer")
                                    event.widget.focus_set()
                                    return
                        if event.widget == self.a_gates[i]:
                            index = -1
                            if self.lkname == 'PRR':
                                min_val,max_val=float(self.Gate_configuration[self.lkname][i][2]),float(self.Gate_configuration[self.lkname][i][3])
                            else:
                                min_val,max_val = 0,float(self.Gate_configuration[self.lkname][i][2])
                                Name = self.Gate_configuration[self.lkname][i][1] + " Anticipated"
                            if self.Gate_configuration[self.lkname][i][1][0] == 'B' and self.lkname != 'TVL':
                                if float(event.widget.get()) == 0.0:
                                    for j in range(len(self.Gate_configuration[self.lkname])):
                                        if self.Gate_configuration[self.lkname][j][1][0] == 'L':
                                            if self.Gate_configuration[self.lkname][j][1][-1] == self.Gate_configuration[self.lkname][i][1][-1]:
                                                self.a_gates[j].delete(0,'end')
                                                self.a_gates[j].insert(0,'0')
                            if self.Gate_configuration[self.lkname][i][1][0] == 'L':
                                try:
                                    int(event.widget.get())
                                except:
                                    self.recheck = True
                                    mb.showwarning(Name + " Not Valid","Must be an integer")
                                    event.widget.focus_set()
                                    return
                    if event.widget in [self.curTemp,self.minTemp,self.maxTemp]:
                        min_val, max_val = -50,130
                    if event.widget == self.curTemp:
                        Name = 'Current Air Temp'
                    if event.widget == self.minTemp:
                        Name = 'Min Air Temp'
                    if event.widget == self.maxTemp:
                        Name = 'Max Air Temp'
                    if event.widget == self.tailTemp:
                        if event.widget.get() == '-901':
                            return
                        else:
                            Name = "Tail Temp"
                            min_val, max_val = 0,50
                    if event.widget in [self.precip,self.snow,self.swe]:
                        min_val, max_val = 0,25
                        stop = False
                    if event.widget == self.precip:
                        Name = "Precipitation"
                    if event.widget == self.snow:
                        Name = "Snow"
                    if event.widget == self.swe:
                        Name = "Snow Water Equivilent"
                        
                    val = float(event.widget.get())
                    if val < min_val:
                        self.recheck = True
                        mb.showwarning(Name +" Not Valid","Value is below normal range.\nPlease Check value.")
                        if stop:
                            event.widget.focus_set()
                        return
                    if val > max_val:
                        self.recheck = True
                        mb.showwarning(Name +" Not Valid","Value is above normal range.\nPlease Check value.")
                        if stop:
                            event.widget.focus_set()
                        return
                else:
                    self.recheck = False
                flow = True
                if index > -1:
                    gates = {}
                    for i in range(len(self.Gate_configuration[self.lkname])):
                        if self.gates[i][index].get() == "":
                            flow = False
                        else:
                            if self.Gate_configuration[self.lkname][i][1] in ['L1','L2']:
                                gates[self.Gate_configuration[self.lkname][i][1]] = int(self.gates[i][index].get())
                            else:
                                gates[self.Gate_configuration[self.lkname][i][1]] = float(self.gates[i][index].get())
                    for key in ['MG1','MG2','BP1','BP2','L1','L2']:
                        if key not in gates.keys():
                            gates[key] = 0
                    if flow:
                        try:
                            self.FlowL[index].configure(text=str(self.flow.get_total_flow(float(self.ElevF[index].get()),gates['MG1'],gates['MG2'],gates['BP1'],gates['BP2'],gates['L1'],gates['L2'])))
                        except:
                            self.FlowL[index].configure(text="Flow Computation Failed")
                flow = True
                if index == -1:
                    gates = {}
                    for i in range(len(self.Gate_configuration[self.lkname])):
                        if self.a_gates[i].get() == "":
                            flow = False
                            self.A_FlowL.configure(text='')
                        else:
                            if self.Gate_configuration[self.lkname][i][1] in ['L1','L2']:
                                gates[self.Gate_configuration[self.lkname][i][1]] = int(self.a_gates[i].get())
                            else:
                                gates[self.Gate_configuration[self.lkname][i][1]] = float(self.a_gates[i].get())
                    for key in ['MG1','MG2','BP1','BP2','L1','L2']:
                        if key not in gates.keys():
                            gates[key] = 0
                    if flow:
                        try:
                            self.A_FlowL.configure(text=str(self.flow.get_total_flow(float(self.ElevF[3].get()),gates['MG1'],gates['MG2'],gates['BP1'],gates['BP2'],gates['L1'],gates['L2'])))
                        except:
                            self.A_FlowL.configure(text="Flow Computation Failed")
            except:
                mb.showwarning(Name + " Entry Not Valid","Must be a number.")
                self.recheck = True
                event.widget.focus_set()
    def Load(self,*args):
        """Checks for the presence of a date stamped file matching the lake and date.
        Parses the file and populates the entry objects"""
        self.Validating = False
        self.Date = self.TkDate.get()
        filename = 'o:\\ed\\public\\dlb\\archive\\'+self.lkname+'pydlb'+self.Date.replace('/','-')+'.txt'
        self.Clear()
        if exists(filename):
            f = open(filename,'r')
            Times = []
            Gates = []
            lines = f.readlines()
            f.close()
            maxRow,a,r=0,0,0
            for line in lines:
                if line[0] != '#':  #Only Process data lines not comments
                    meta,data = line.split(':')  #Seperate metadata from data
                    meta = meta.split(' ')  #Break meta data into array
                    if meta[4] == 'MODTIME':
                        pass
                    elif meta[4] == 'ELEV':
                        if meta[3] in Times:
                            row = Times.index(meta[3])
                        else:
                            row = maxRow
                            self.DateF[row].configure(text=meta[2])
                            self.TimeF[row].insert(0,meta[3])
                            Times.append(meta[3])
                            maxRow += 1
                        self.ElevF[row].insert(0, data[:-1])
                    elif meta[4] == 'TAILWATER':
                        self.TailWaterF[row].insert(0, data[:-1])
                    elif meta[4] in ['MG1','BP1','L1','MG2','BP2','L2']:
                        if meta[4] in Gates:
                            self.gates[Gates.index(meta[4])][row].delete(0,"end")
                            self.gates[Gates.index(meta[4])][row].insert(0,data[:-1])
                        else:
                            Gates.append(meta[4])
                            self.gates[Gates.index(meta[4])][row].delete(0,"end")
                            self.gates[Gates.index(meta[4])][row].insert(0,data[:-1])
                    elif meta[4].find('_ANTICIPATED_')>0:
                        self.a_gates[a].insert(0,data[:-1])
                        a+=1
                    elif meta[4] == 'CHANGE':
                        self.change.insert(0,data[:-1])
                    elif meta[4] == 'AMTRAIN':
                        self.precip.insert(0,data[:-1])
                    elif meta[4] == 'SNOW':
                        self.snow.insert(0,data[:-1])
                    elif meta[4] == 'SNOWWATER':
                        self.swe.insert(0,data[:-1])
                    elif meta[4] == 'PRESWEATHR':
                        self.weather.set(data[:-1])
                    elif meta[4] == 'AIR':
                        self.curTemp.insert(0,data[:-1])
                    elif meta[4] == 'MAX':
                        self.maxTemp.insert(0,data[:-1])
                    elif meta[4] == 'MIN':
                        self.minTemp.insert(0,data[:-1])
                    elif meta[4] == 'WATERTEMP':
                        self.tailTemp.insert(0,data[:-1])
                    elif meta[4] == 'REMARKS':
                        self.remarks.insert(0,data[:-1])
                    else:
                        self.r_station[r].insert(0,data[:-1])
                        r+=1
            i = 0
            while self.gates[0][i].get() != '':
                if i > (self.numrows-1):
                    self.AddGateRow()
                i+=1
            self.Validating = True
            for i in range(20):
                self.ElevF[i].focus_force()
                self.ElevF[i].event_generate('<FocusOut>')
            self.root.update_idletasks()
            self.a_gates[0].event_generate('<FocusOut>')
        else:
            maxRow = 4
            year,month,day,hour,Min,sec,wd,yd,dst = time.gmtime(time.time()-(self.Entry_dates.index(self.Date)+1)*60*60*24)
            yesterday = str(month)+'/'+str(day)+'/'+str(year)
            dates = [yesterday]*3 +[self.Date]+['']*16
            times = ['1200','1800','2400','0600'] + ['']*16
            for i in range(4):
                self.DateF[i].configure(text=dates[i])
                self.TimeF[i].insert(0,times[i])
                if times[i] == '2400':
                    h,m = '00','00'
                    mon,day,year = self.Date.split('/')
                else:
                    h,m = int(int(times[i])/100), int(times[i])%100
                    mon,day,year = dates[i].split('/')
                try:
                    self.ElevF[i].insert(0,self.Data[self.lkname][year+'-'+pad(mon,2,'0')+'-'+pad(day,2,'0') + ' '+pad(str(h),2,'0')+':'+pad(str(m),2,'0')])
                except:
                    pass
                try:
                    self.TailWaterF[i].insert(0,self.Data['Tailwater'][year+'-'+pad(mon,2,'0')+'-'+pad(day,2,'0') + ' '+pad(str(h),2,'0')+':'+pad(str(m),2,'0')])
                except:
                    pass
            mon2,day2,year2 = dates[0].split('/')
            try:
                self.change.insert(0,str(round(self.Data[self.lkname][year+'-'+pad(mon,2,'0')+'-'+pad(day,2,'0') + ' 06:00'] - self.Data[self.lkname][year2+'-'+pad(mon2,2,'0')+'-'+pad(day2,2,'0') + ' 06:00'],2)))
            except:
                pass
            mon,day,year = self.Date.split('/')
            for i in range(len( self.River_Stations[self.lkname])):
                try:
                    self.r_station[i].insert(0,LastGood(self.Data[self.River_Stations[self.lkname][i]], year+'-'+pad(mon,2,'0')+'-'+pad(day,2,'0') + ' 06:00'))
                except:
                    self.r_station[i].insert(0,'0')
            try:
                self.tailTemp.insert(0,self.Data['WaterTemp'][year+'-'+pad(mon,2,'0')+'-'+pad(day,2,'0') + ' 06:00'])
            except:
                pass
        while maxRow < self.numrows:
            self.RemoveGateRow()
        self.Validating = True
                    
    def Clear(self):
        """Clears all of the values in the entry objects"""
        for i in range(20):
            self.DateF[i].configure(text='')
            for o in [self.TimeF,self.ElevF,self.TailWaterF]:
                o[i].delete(0,"end")
            self.FlowL[i].configure(text="")
            for j in range(len(self.gates)):
                self.gates[j][i].delete(0,"end")
        for o in [self.change,self.precip,self.snow,self.swe,self.curTemp,self.minTemp,self.maxTemp,self.tailTemp]:
            o.delete(0,"end")
        self.weather.set('Select Weather')
        for i in range(len( self.Gate_configuration[self.lkname])):
            self.a_gates[i].delete(0,"end")
        for i in range(len( self.River_Stations[self.lkname])):
            self.r_station[i].delete(0,"end")
        self.remarks.delete(0,"end")
if __name__ == "__main__":
        g = gui()
